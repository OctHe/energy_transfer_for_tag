%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Simulation of beamforming for multiple backscatter
% 1. Each tag transmit the signal one-by-one without frequency offset. The 
% frequency offset of each tag does not affect our design because we use a 
% power-based channel estimation.
% 2. Actually, This design can tranfer to a FDMA system where each tag 
% shift the signal to a orthogonal frequency.
% 3. The goal of this design is to fair the received power at the receiver
% instead of fairing the power at each tag. This is not practice in the 
% real world and need to be fixed.
% 4. The received signal detection at the receiver is not well-introduced. 
% This is also impractical and need to be fixed.
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear;
close all;

%% Params
Np = 2;     % The number of power sources
Nt = 2;     % The number of tags

Rp = 64;

%% Channel model
% Channel repoci
Hf = rand(Nt, Np) .* exp(2j * pi * rand(Nt, Np));
Hb = rand(1, Np) .* exp(2j * pi * rand(1, Nt));
Hb = Hf.';

%% RSS probe generation and signal reflection
pre_tx = kron(ones(1, Nt), PhaseMatrixGenerator(Np, Rp));
pre_tag = kron(eye(Nt), ones(1, Rp^(Np-1)));

Z = Hf * pre_tx;
Y = Hb * (pre_tag .* Z);
Y = reshape(Y, [], Nt);

%% Received power at the receiver
rx_power = abs(Y).^2;

%% Tag grouping and phase alignment



weight_mat = PhaseMatrixGenerator(Np, Rp);
[~, bf_index] = max(min(rx_power, [], 1));
bf_weight = weight_mat(:, bf_index);

%% Evaluation
% Power transfer w/ beamforming
Z = Hf * bf_weight;
Y = Hb * (eye(Nt) .* Z);

rx_power_w_bf = abs(Y).^2;
rx_power_w_bf = reshape(rx_power_w_bf, [], Nt);

% Power transfer w/o beamforming
Z = Hf * (1/Np * ones(Np, 1));
Y = Hb * (eye(Nt) .* Z);

rx_power_wo_bf = abs(Y).^2;
rx_power_wo_bf = reshape(rx_power_wo_bf, [], Nt);

% Beamforming gain
bf_gain = min(rx_power_w_bf) / min(rx_power_wo_bf)

%% figure

figure;
plot(rx_power);
